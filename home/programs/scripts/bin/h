#!/usr/bin/env python3

"""Nix helper"""

import argparse
import functools
import inspect
import os
import platform
import re
import subprocess
from collections import defaultdict
from typing import List


HOME = os.getenv("HOME")
HOST = platform.node()
OS = platform.system()
FLAKE_PATH = f"{HOME}/.nixpkgs" if OS == "Darwin" else "/etc/nixos"
SYSTEM_PROFILE = "/nix/var/nix/profiles/system"
NIXOS_REBUILD = ("darwin" if OS == "Darwin" else "nixos") + "-rebuild"


_commands = set()
_command_aliases = {}
_actions = defaultdict(set)
_action_aliases = defaultdict(dict)


def command(aliases=None):
    """Make function a cli command"""

    def decorator_command(command_func):
        command_name = command_func.__name__
        _commands.add(command_name)
        while aliases:
            _command_aliases[aliases.pop()] = command_name

        def action(aliases=None):
            """Make function an action of a cli command"""

            def decorator_action(action_func):
                _, action_name = action_func.__name__.split("_")
                _actions[command_name].add(action_name)
                while aliases:
                    _action_aliases[command_name][aliases.pop()] = action_name

                @functools.wraps(action_func)
                def wrapper(*args, **kwargs):
                    action_func(*args, **kwargs)

                return wrapper

            return decorator_action

        command_func.action = action

        @functools.wraps(command_func)
        def wrapper(*args, **kwargs):
            return command_func(*args, **kwargs)

        return wrapper

    return decorator_command


class CommandNotExists(Exception):
    pass


def aliases_from_command(command_):
    return [al for al, com in _command_aliases.items() if com == command_]


def aliases_from_action(command_, action):
    return [al for al, ac in _action_aliases[command_].items() if ac == action]


def command_forwards_arguments(f):
    return str(inspect.signature(f)) in {"(*args)", "(*args, *kwargs)"}


def is_command(command_):
    return command_ in _commands


def follow_aliases(func):
    """Substitute aliases with commands or actions"""

    @functools.wraps(func)
    def wrapper(command_, args, *pargs):
        if command_ not in _commands and command_ not in _command_aliases:
            raise CommandNotExists("command does not exist")
        command_ = _command_aliases.get(command_, command_)
        if "action" in args:
            args.action = (
                _action_aliases.get(command_).get(args.action) or args.action
            )
        return func(command_, args, *pargs)

    return wrapper


@follow_aliases
def execute_command(command_, args, unknown):
    action = None
    if "action" in args:
        action = args.action
        del args.action
    function_name = f"{command_}_{action}" if action else command_
    command_function = (
        globals()[function_name] if command_ in _commands else None
    )
    pargs = unknown if command_forwards_arguments(command_function) else []
    return command_function(*pargs, **vars(args))


def add_parser(subparsers, name, command_=None):
    aliases = (
        aliases_from_action(command_, name)
        if command_
        else aliases_from_command(name)
    )
    function_name = f"{command_}_{name}" if command_ else name
    if function_name not in globals():
        raise NameError(f"function '{function_name}' is not defined")
    doc = globals()[function_name].__doc__
    help_ = doc.split("\n\n", maxsplit=1)[0].strip() if doc else None
    return subparsers.add_parser(name, aliases=aliases, help=help_)


def parameter_docs(func):
    if not func.__doc__:
        return {}
    docs = re.split(r"-+", func.__doc__)
    if len(docs) < 2:
        return {}
    doc = docs[1]
    param_docs = re.findall(r"(?P<name>\w+)\n\s*(?P<doc>.+)\n", doc)
    return dict(param_docs)


def function_args_to_cli_args(name: str, command_=None):
    cli_arguments = []
    func = globals()[f"{command_}_{name}"] if command_ else globals()[name]
    fullargspec = inspect.getfullargspec(
        func.__dict__.get("__wrapped__", func)
    )
    defaults = fullargspec.defaults
    for i, arg in enumerate(fullargspec.args):
        cli_argument = {}
        cli_argument["name"] = arg
        type_ = fullargspec.annotations.get(arg, str)
        if hasattr(type_, "__origin__") and type_.__origin__ is list:
            type_ = type_.__args__[0]
            cli_argument["nargs"] = "+"
        cli_argument["type"] = type_
        cli_argument["default"] = (
            defaults[i] if defaults and i < len(defaults) else None
        )
        if cli_argument["default"]:
            cli_argument["nargs"] = "?"
        cli_argument["help"] = parameter_docs(func).get(arg)
        cli_arguments.append(cli_argument)
    return cli_arguments


def parse_args():
    parser = argparse.ArgumentParser(description="Nix helper")
    if not _commands:
        return parser.parse_known_args()
    subparsers = parser.add_subparsers(
        dest="command", help="command to execute", required=True
    )
    for command_ in _commands:
        subparser_command = add_parser(subparsers, command_)
        for command_argument in function_args_to_cli_args(command_):
            name = command_argument.pop("name")
            subparser_command.add_argument(name, **command_argument)
        if not _actions[command_]:
            continue
        subparsers_command_actions = subparser_command.add_subparsers(
            dest="action", help="action to do", required=True
        )
        for action in _actions[command_]:
            subparser_action = add_parser(
                subparsers_command_actions, action, command_
            )
            for action_argument in function_args_to_cli_args(
                action, command_=command_
            ):
                name = action_argument.pop("name")
                subparser_action.add_argument(name, **action_argument)
    return parser.parse_known_args()


def cli():
    args, unknown = parse_args()
    if "command" not in args:
        return None
    command_ = args.command
    del args.command
    return execute_command(command_, args, unknown)


@command(["b"])
def build(*args):
    """Build a Nix expression"""
    options = list(args)
    return subprocess.run(["nix-build"] + options, check=False)


@command(["c"])
def check():
    """Check whether the flake evaluates and run its tests"""
    return subprocess.run(["nix", "flake", "check"], check=False)


@command(["g"])
def generations():
    """Explore, manage generations"""


@generations.action(["ls"])
def generations_list():
    """List generations"""
    return subprocess.run(
        (["sudo"] if OS == "Linux" else [])
        + [
            "nix-env",
            "--list-generations",
            "--profile",
            SYSTEM_PROFILE,
        ],
        check=False,
    )


@generations.action(["rm"])
def generations_remove(generations_: List[str]):
    """
    Remove generations

    Parameters
    ----------
    generations
        generations to remove
    """
    return subprocess.run(
        (["sudo"] if OS == "Linux" else [])
        + ["nix-env", "--delete-generations"]
        + generations_
        + ["--profile", SYSTEM_PROFILE],
        check=False,
    )


@command(["rb"])
def rebuild(*args):
    """Rebuild the current system's flake"""
    options = list(args)
    return subprocess.run(
        (["sudo"] if OS == "Linux" else [])
        + [NIXOS_REBUILD, "switch", "--flake", f"{FLAKE_PATH}#{HOST}"]
        + options,
        check=False,
    )


@command(["s"])
def search(package: str):
    """
    Search nixpkgs for a package

    Parameters
    ----------
    package
        package name
    """
    return subprocess.run(["nix", "search", "nixpkgs", package], check=False)


@command(["sh"])
def shell(packages: List[str]):
    """
    Run a shell in which the specified packages are available

    Parameters
    ----------
    packages
        package names
    """
    packages = [f"nixpkgs#{p}" for p in list(packages)]
    return subprocess.run(["nix", "shell"] + packages, check=False)


@command(["u"])
def update(*args):
    """Update flake lock file"""
    options = list(args)
    return subprocess.run(["nix", "flake", "update"] + options, check=False)


if __name__ == "__main__":
    cli()
